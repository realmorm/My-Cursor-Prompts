Key Principles

- Write concise, technical Dart code with accurate examples
- Use functional and declarative programming patterns where appropriate
- Prefer composition over inheritance
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Structure files: exported widget, subwidgets, helpers, static content, types

Project Structure

- Follow feature-first architecture with clean architecture principles
- Use MVVM pattern for presentation layer
- Create folders only when you have 2+ files to organize
- Start with single files, create folders as needed organically
- Avoid premature folder structure creation

Architecture Layout:

```
lib/
├── _core/           # Global resources (theme, constants, network, etc.)
├── _shared/         # Features used by 2+ other features
└── {feature}/       # Individual feature modules
    ├── data/        # DTOs, datasources (optional)
    ├── domain/      # Entities, repositories, business logic
    └── presentation/ # Screens, viewmodels, widgets, sections
```

Data Layer Conventions:

- Separate entity (domain) and dto (data) models for clean boundaries
- Repository pattern without separate datasource layer (avoid unnecessary abstraction)
- Minimize logic, create only when needed

Dart/Flutter

- Use const constructors for immutable widgets
- Leverage Freezed for immutable state classes and unions
- Use arrow syntax for simple functions and methods
- Prefer expression bodies for one-line getters and setters
- Use trailing commas for better formatting and diffs

Riverpod Guidelines

- Use @riverpod annotation for generating providers
- Prefer AsyncNotifierProvider and NotifierProvider over StateProvider
- Avoid StateProvider, StateNotifierProvider, and ChangeNotifierProvider
- Use ref.invalidate() for manually triggering provider updates
- Use ConsumerWidget with Riverpod for state-dependent widgets
- Use HookConsumerWidget when combining Riverpod and Flutter Hooks

Performance Optimization

- Use const widgets where possible to optimize rebuilds
- Implement list view optimizations (e.g., ListView.builder)
- Use AssetImage for static images and cached_network_image for remote images
- Optimize for Flutter performance metrics (first meaningful paint, time to interactive)

UI and Styling

- Prioritize using \_core/theme/ resources (colors.dart, sizes.dart, text_styles.dart) over hardcoded values
- Use Flutter's built-in widgets and create custom widgets
- Implement RefreshIndicator for pull-to-refresh functionality
- In TextFields, set appropriate textCapitalization, keyboardType, and textInputAction

Model and Database Conventions

- Use Freezed for all data models (immutability FTW, bro)
- Annotate models with @JsonSerializable(fieldRename: FieldRename.snake)
- For read-only fields, use @JsonKey(includeFromJson: true, includeToJson: false)
- Use @JsonValue(int) for enums that go to the database

Code Generation

- Utilize build_runner for generating code from annotations (Freezed, Riverpod, JSON serialization)
- Run 'fvm flutter pub run build_runner build --delete-conflicting-outputs' after modifying annotated classes

Miscellaneous

- Use logger from lib/\_core/logging/logger.dart instead of print for debugging
- Use Flutter Hooks / Riverpod Hooks where appropriate
- Keep lines no longer than 80 characters, adding commas before closing brackets for multi-parameter functions
